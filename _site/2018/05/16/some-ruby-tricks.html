<!Doctype html>

<html><head>
    <meta charset="utf-8">
    <title>Victor's Site</title>
    <link rel="stylesheet" href="/css/main.css" >
</head>
<body><header>
    <h1>Victor Lymar</h1>
</header>


<main class="page-content">
            <div class="wrapper">
                <article>

    <header>
        <h1>Some Ruby Tricks</h1>
    </header>

    <div>
        <blockquote>
  <p>Then they come up to me and say, “I was surprised by this feature of the language, so therefore Ruby violates the principle of least surprise.” Wait. Wait. The principle of least surprise is not for you only. The principle of least surprise means principle of least my surprise. And it means the principle of least surprise after you learn Ruby very well.</p>
</blockquote>

<blockquote>
  <p>Yukihiro Matsumoto <a href="https://www.artima.com/intv/ruby4.html">https://www.artima.com/intv/ruby4.html</a></p>
</blockquote>

<p>Over 4 years of working with Ruby I’ve learned a couple of tricks, conventions and footguns. Here are a few.</p>

<h2 id="irb--rails-console">IRB / Rails console</h2>
<p>The REPL is a programmer’s best friend.</p>

<h3 id="_-evaluates-to-the-repls-last-return-value">“<code>_</code>” evaluates to the REPL’s last return value</h3>

<pre><code class="language-ruby">irb(main):&gt; [1, 2, 3].reduce(:+)
=&gt; 6

&gt; _
=&gt; 6

&gt; _ + 1
=&gt; 7

</code></pre>

<p>You’re patting yourself on the back for that slick one-liner you just got right on your first try, but then you realize…._you forgot to add one to it_. Quickly re-use the return value of the previous expression with the <code>_</code> keyword.</p>

<h3 id="-nil-for-your-sanity"><code>; nil</code> for your sanity</h3>
<p>A common irb workflow is to iteratively build up a short program, saving intermediate variables along the way. Assignment (<code>=</code>) is an expression in Ruby, meaning it returns the value that was assigned. If you’re assigning a large object, you might be stuck for a while watching output scroll by.</p>

<p>Rails example:</p>
<pre><code class="language-ruby">&gt; bobs = Users.where(name: "Bob")
=&gt; &lt; 30 seconds of ActiveRecord objects being printed to the console &gt;
</code></pre>

<p>My workaround is to append <code>; nil</code> to each line. The assignment still happens, but the REPL will quickly print <code>nil</code>, letting you keep working on your program.</p>

<p>Example:</p>
<pre><code class="language-ruby">&gt; bobs = Users.where(name: "Bob"); nil
=&gt; nil
&gt; adult_bobs = bobs.where("age &gt; ?", 30); nil
=&gt; nil
&gt; adult_bobs.count
=&gt; 100
</code></pre>

<h3 id="easy-introspection">Easy introspection</h3>
<p>Ruby has the most intuitive and comprehensive standard library I’ve ever seen. I’ll find myself wondering “Does X support operation Y?” and more often than not, it does (though I’ve been working with Rails for so long that sometimes the lines between ActiveSupport and the standard lib. are blurred). Take advantage of the fact that ruby has great introspection features and that everything is an object.</p>

<pre><code class="language-ruby">&gt; Array.methods
=&gt; [:[], :try_convert, :new, :allocate, :superclass, :&lt;=&gt;, :module_exec, :class_exec, :&lt;=, :&gt;=, :==, :===, :include?, :included_modules, :ancestors, :name, :public_instance_methods, :instance_methods, :private_instance_methods, :protected_instance_methods, :const_get, :constants, :const_defined? 
    ...
</code></pre>

<p><code>Object#methods</code> returns <em>all</em> the methods for the object, including inherited ones, which can be overwhelming. Here’s a trick for pruning out the superclass methods:</p>

<pre><code class="language-ruby">&gt; Array.methods - Array.superclass.methods
=&gt;[:[], :try_convert]
</code></pre>

<p>Usually the bulk of the methods I’m trying to filter out belong to <code>Object</code>, so I’ll just subtract <code>Object.methods</code> instead of typing out <code>SomeKlass.superclass.methods</code>.</p>

<p>Note that the previous above only returns <code>Array</code>’s class methods. To get the instance methods:</p>

<pre><code class="language-ruby">&gt; arr_methods = Array.new.methods - Object.new.methods
=&gt; [:transpose, :fill, :assoc, :rassoc, :uniq, :uniq!, :compact, :compact!, :to_h, :flatten, :flatten!, :shuffle!, :include?, :permutation, :combination, :sample, :repeated_combination, :shuffle, :product, :bsearch, :bsearch_index, :repeated_permutation, :shelljoin, :map!, :&amp;, :*,
    ...
</code></pre>

<p>Sometime’s I’ll just <code>sort</code> and scan the methods. Other time’s I have a sense of what I’m looking for and I’ll <code>Array#grep</code>. Two things worth mentioning:</p>
<ol>
  <li><a href="https://ruby-doc.org/core-2.5.1/Array.html">Ruby-doc.org</a> is a fantastic source of documentation.</li>
  <li><a href="http://pryrepl.org/">Pry</a> is a much more powerful way to introspect on Ruby classes (and much more).</li>
</ol>

<h2 id="patterns">Patterns</h2>
<p>Here are some patterns often found in Ruby projects.</p>

<h3><code>||=</code></h3>
<p>Commonly used to assign a variable who’s current value is nil. Takes advantage of the fact that <code>nil</code> evaluates as <code>false</code> in Ruby.</p>

<pre><code class="language-ruby">foo = nil
foo ||= 1
foo ||= 2 # does not assign 2
foo == 1 #=&gt; true
</code></pre>

<h3 id="symbolto_proc"><code>Symbol#to_proc</code></h3>
<p>One of the less immediately intuitive keywords in Ruby is <code>&amp;:symbol</code>, which is a shorthand for <code>Symbol#to_proc</code> (<a href="[https://ruby-doc.org/core-2.5.1/Symbol.html#method-i-to%5C_proc]">documentation</a>).</p>

<pre><code class="language-ruby">[1, 2, 3].map(&amp;:to_s) #=&gt; ["1", "2", "3"]
[1, 2, 3].select(&amp;:even?) #=&gt; [2]

# equivalent to the above:
[1, 2, 3].map { |i| i.to_s } #=&gt; ["1", "2", "3"]
[1, 2, 3].select { |i| i.even? } #=&gt; [2]
</code></pre>

<p><code>Symbol#to_proc</code>  returns a <code>Proc</code> that accepts a single argument and then calls the method named by the symbol on that argument.</p>

<h3 id="struct">Struct</h3>
<p><code>Person = Struct.new(:name, :birthdate)</code></p>
<pre><code class="language-ruby">class Person &lt; Struct.new(:name, :birthdate)
  def birth_year
    @birthdate.year
  end
endel
</code></pre>

<h3 id="-vs-and--vs-or"><code>&amp;&amp;</code> vs <code>and</code>, <code>||</code> vs <code>or</code></h3>
<p>When I was mentoring interns at Scribd, a common issue was use of <code>and</code> and <code>or</code> (particularly with developers with Python backgrounds).
TODO</p>

<h3 id="class--self"><code>class &lt;&lt; self</code></h3>
<p>TODO</p>


    </div>

</article>

            </div>
        </main>
    </body>

</html>
